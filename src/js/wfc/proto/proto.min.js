/*
 * Copyright (c) 2020 WildFireChat. All rights reserved.
 */

// import proto from 'node-loader!../../../marswrapper.node';
import Message from '../messages/message';
import Conversation from '../model/conversation';
import ConversationInfo from '../model/conversationInfo';
import {EventEmitter} from 'events';
import EventType from '../client/wfcEvent'
import UserInfo from '../model/userInfo';
import NullUserInfo from '../model/nullUserInfo';
import NullGroupInfo from '../model/nullGroupInfo';
import GroupInfo from '../model/groupInfo';
import GroupMember from '../model/groupMember';
import UserSettingScope from '../client/userSettingScope';
import CreateGroupNotification from '../messages/notification/createGroupNotification';
import MessageContentMediaType from '../messages/messageContentMediaType';
import AddGroupMemberNotification from '../messages/notification/addGroupMemberNotification';
import MessageConfig from '../client/messageConfig';
import UnreadCount from '../model/unreadCount';
import ConversationSearchResult from '../model/conversationSearchResult';
import MessageStatus from '../messages/messageStatus';
import MessageContent from '../messages/messageContent';
import GroupSearchResult from '../model/groupSearchResult';
import FriendRequest from '../model/friendRequest';
import ChatRoomMemberInfo from '../model/chatRoomMemberInfo';
import ChannelInfo from '../model/channelInfo';
import ConversationType from '../model/conversationType';
import TextMessageContent from '../messages/textMessageContent';
import ConnectionStatus from '../client/connectionStatus';
import Long from 'long';
import Config from "../../config";
import ChatRoomInfo from "../model/chatRoomInfo";
import QuitGroupNotification from "../messages/notification/quitGroupNotification";
import DismissGroupNotification from "../messages/notification/dismissGroupNotification";
import ModifyGroupAliasNotification from "../messages/notification/modifyGroupAliasNotification";
import ReadEntry from "../model/readEntry";
import errorCode from "../client/errorCode";
import {promises as fs} from 'fs';
import FileRecord from "../model/fileRecord";
import MediaMessageContent from "../messages/mediaMessageContent";


var proto = null;

var lastScreenShotTime = 0;

/**
 * java long 类型在 javascript 类型的映射说明:
 * 字段messageUid 对应 Long 对象
 * 其他 long 类型的变量 对应 number
 *
 * node addon 和 proto.min.js 之间 java long类型数据的传递
 * 双向传递时，都需 java long 类型的数据转换成字符串传递
 *
 */
class WfcImpl {
    connectionStatus = 0;
    userId = '';
    token = '';
    users = new Map();
    groups = new Map();
    isLogined = false;

    // TODO 移除吧，全都走EventEmitter
    // onReceiveMessageListeners = [];

    messageContentList = [];

    eventEmitter = new EventEmitter();

    onConnectionChanged(status) {
        if (!self.isLogined && status == ConnectionStatus.ConnectionStatusConnected) {
            self.isLogined = true;
        }
        self.connectionStatus = status;
        self.eventEmitter.emit(EventType.ConnectionStatusChanged, status);
        console.log('connection status changed', status);
    }

    // /**
    //  *
    //  * @param {function} listener
    //  */
    // setOnReceiveMessageListener(listener) {
    //     if (typeof listener !== 'function') {
    //         console.log('listener should be a function');
    //         return;
    //     }
    //     self.onReceiveMessageListeners.forEach(l => {
    //         l === listener
    //         return
    //     });
    //     self.onReceiveMessageListeners.push(listener);
    // }

    // removeOnReceiMessageListener(listener) {
    //     if (typeof listener !== 'function') {
    //         console.log('listener should be a function');
    //         return;
    //     }
    //     self.onReceiveMessageListeners.splice(self.onReceiveMessageListeners.indexOf(listener), 1);
    // }

    onReceiveMessage(messages, hasMore) {
        if (!self.isLogined) {
            return;
        }
        // receiving
        if (self.connectionStatus === 2) {
            return;
        }
        var msgs = JSON.parse(messages);
        msgs.forEach(m => {
            let msg = Message.fromProtoMessage(m);
            // self.onReceiveMessageListeners.forEach(listener => {
            //     listener(msg, hasMore);
            // });
            if (msg) {
                self.eventEmitter.emit(EventType.ReceiveMessage, msg);
            }
        });
    }

    onConferenceEvent(event){
        self.eventEmitter.emit(EventType.ConferenceEvent, event)
    }

    onGroupInfoUpdate(groupListIds) {
        if (!self.isLogined) {
            return;
        }

        let groupIdArray = JSON.parse(groupListIds);

        let groupInfos = [];
        groupIdArray.forEach((groupId => {
            self.groups.delete(groupId);
            groupInfos.push(self.getGroupInfo(groupId, false));
        }))
        self.eventEmitter.emit(EventType.GroupInfosUpdate, groupInfos);
    }

    onChannelInfoUpdate(channelListIds) {
        // TODO
        if (!self.isLogined) {
            return;
        }
    }

    onGroupMemberUpdateListener(groupId) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.GroupMembersUpdate);
    }

    onSettingUpdate() {
        if (!self.isLogined) {
            return;
        }
        // TODO 具体更新的信息
        self.eventEmitter.emit(EventType.SettingUpdate);
    }

    onRecallMessage(operatorUid, messageUid) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.RecallMessage, operatorUid, Long.fromValue(messageUid));
    }

    onDeleteRemoteMessage(messageUid) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.MessageDeleted, Long.fromValue(messageUid));
    }

    onUserReceivedMessage(receivedMapStr) {
        if (!self.isLogined) {
            return;
        }
        let deliveries = JSON.parse(receivedMapStr);
        let deliveryMap = new Map();
        deliveries.forEach(e => {
            deliveryMap.set(e.key, e.value);
        });
        self.eventEmitter.emit(EventType.MessageReceived, deliveryMap);
        console.log('onreceive', deliveryMap);
    }

    onUserReadedMessage(readedMapStr) {
        if (!self.isLogined) {
            return;
        }
        // [{"userId":"GNMtGtZZ","conversationType":1,"target":"Jl8jLjkk","line":0,"readDt":1590308777299} ]
        let arr = JSON.parse(readedMapStr);
        let readEntries = [];
        arr.forEach(e => {
            let entry = new ReadEntry();
            entry.userId = e.userId;
            entry.conversation = new Conversation(e.conversationType, e.target, e.line);
            entry.readTime = e.readDt;
            readEntries.push(entry);
        })
        self.eventEmitter.emit(EventType.MessageRead, readEntries);
        console.log('onread', readEntries)
    }

    onMessageDeleted(messageId) {
        if (!self.isLogined) {
            return;
        }
        self.eventEmitter.emit(EventType.DeleteMessage, messageId);
    }

    onUserInfoUpdate(userIds) {
        if (!self.isLogined) {
            return;
        }
        let userIdArray = JSON.parse(userIds);

        userIdArray.forEach((userId => {
            self.users.delete(userId);
        }))
        let userInfos = self.getUserInfos(userIdArray)
        self.eventEmitter.emit(EventType.UserInfosUpdate, userInfos);
    }

    onFriendListUpdate(friendListIds) {
        if (!self.isLogined) {
            return;
        }
        console.log('friendList update, ids', friendListIds);
        let ids = JSON.parse(friendListIds);
        ids.forEach((uid) => {
            self.users.delete(uid);
        });
        self.eventEmitter.emit(EventType.FriendListUpdate, ids);
    }

    onFriendRequestUpdate(newRequests = '[]') {
        if (!self.isLogined) {
            return;
        }
        console.log('friend request list update, new incomming requests', newRequests);
        let ids = JSON.parse(newRequests);
        self.eventEmitter.emit(EventType.FriendRequestUpdate, ids);
    }

    init(args = []) {
        proto = args[0];
        // if(process.platform === 'win32'){
        //     proto.setDBPath(process.cwd());
        // }
        proto.setConnectionStatusListener(self.onConnectionChanged);
        //proto.setReceiveMessageListener(self.onReceiveMessage, self.onRecallMessage);
        proto.setReceiveMessageListener(self.onReceiveMessage, self.onRecallMessage, self.onDeleteRemoteMessage, self.onUserReceivedMessage, self.onUserReadedMessage);
        proto.setConferenceEventListener(self.onConferenceEvent);
        proto.setUserInfoUpdateListener(self.onUserInfoUpdate);
        proto.setFriendUpdateListener(self.onFriendListUpdate);
        proto.setFriendRequestListener(self.onFriendRequestUpdate);
        proto.setGroupInfoUpdateListener(self.onGroupInfoUpdate);
        proto.setSettingUpdateListener(self.onSettingUpdate);
        proto.setChannelInfoUpdateListener(self.onChannelInfoUpdate);
        proto.setGroupMemberUpdateListener(self.onGroupMemberUpdateListener);
        proto.setLanguage(Config.LANGUAGE);
        self.registerDefaultMessageContents();
    }

    registerMessageContent(name, flag, type, clazz) {
        MessageConfig.MessageContents.push(
            {
                name: name,
                flag: flag,
                type: type,
                contentClazz: clazz,
            }
        );

    }

    async connect(userId, token) {
        self.userId = userId;
        proto.connect(userId, token);

        // for testing your code
        // self.test();
    }

    disconnect() {
        self.userId = '';
        proto.disconnect(0);


        //sleep 1 second wait disconnect with im server
        var now = new Date();
        var exitTime = now.getTime() + 1000;
        while (true) {
            now = new Date();
            if (now.getTime() > exitTime)
                return;
        }
    }

    registerDefaultMessageContents() {
        MessageConfig.MessageContents.map((e) => {
            proto.registerMessageFlag(e.type, e.flag);
            self.registerMessageContent(e.type, e.content);
        });
    }

    getClientId() {
        return proto.getClientId();
    }

    getUserId() {
        return self.userId;
    }

    getServerDeltaTime() {
        return proto.getServerDeltaTime();
    }


    screenShot() {
        var now = new Date();
        if (now.getTime() - lastScreenShotTime < 2000) {
            return;
        }
        var ret = proto.screenShot();
        now = new Date();
        lastScreenShotTime = now.getTime();
        return ret;
    }

    isLogin() {
        // return proto.isLogin();
        return self.isLogined;
    }

    getConnectionStatus() {
        return proto.getConnectionStatus();
    }

    setBackupAddressStrategy(strategy) {
        proto.setBackupAddressStrategy(strategy);
    }

    setBackupAddress(backupHost, backupPort) {
        proto.setBackupAddress(backupHost, backupPort);
    }

    onAppResume() {
      proto.onAppResume();
    }

    onAppSuspend() {
      proto.onAppSuspend();
    }

    // setLanguage(language) {
    //     proto.setLanguage(language);
    // }

    getMyGroupList() {
        let settings = this.getUserSettings(UserSettingScope.FavoriteGroup);
        let groupInfos = settings.filter(setting => setting.value === '1')
            .map(setting => this.getGroupInfo(setting.key, false));
        return groupInfos;
    }

    /**
     * @param {string} userId
     * @param {bool} fresh
     */
    getUserInfo(userId, fresh = false, groupId = '') {
        if (!userId || userId === '') {
            return new NullUserInfo('');
        }
        let userInfo;
        if (!fresh && (!groupId || groupId === '')) {
            userInfo = self.users.get(userId);
            if (userInfo) {
                return userInfo;
            }
        }

        console.log('getuserInfo', userId, fresh, groupId);
        let userInfoStr = proto.getUserInfo(userId, fresh, groupId);
        if (userInfoStr === '') {
            userInfo = new NullUserInfo(userId);
        } else {
            userInfo = Object.assign(new UserInfo(), JSON.parse(userInfoStr));
        }
        if (!groupId || groupId === '') {
            self.users.set(userInfo.uid, userInfo);
        }
        return userInfo;
    }

    getUserInfos(userIds, groupId = '') {
        let users = [];
        let userInfoStrs = proto.getUserInfos(userIds, groupId);
        if (userInfoStrs && userInfoStrs !== '') {
            let tmp = JSON.parse(userInfoStrs);
            tmp.forEach((u) => {
                let userInfo = Object.assign(new UserInfo(), u);
                users.push(userInfo)
            });
        }
        return users;
    }

    async getUserInfoEx(userId, refresh, successCB, failCB) {
        proto.getUserInfoEx(userId, refresh, (userInfoStr) => {
            userInfo = Object.assign(new UserInfo(), JSON.parse(userInfoStr));

            if (successCB) {
                successCB(userInfo);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    async searchUser(keyword, searchType, page, successCB, failCB) {
        proto.searchUser(keyword, searchType, page, (result) => {
            let userListStr = JSON.parse(result);
            let userList = [];
            if (userListStr && userListStr.length > 0) {
                userListStr.forEach(u => {
                    userList.push(Object.assign(new UserInfo(), u));
                });
            }
            if (successCB) {
                successCB(userList);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    searchFriends(keyword) {
        let result = proto.searchFriends(keyword);
        let userListStr = JSON.parse(result);
        let userList = [];
        if (userListStr && userListStr.length > 0) {
            userListStr.forEach(u => {
                userList.push(Object.assign(new UserInfo(), u));
            });
        }
        return userList;
    }

    searchGroups(keyword) {
        let result = proto.searchGroups(keyword);
        let groupSearchResultListStr = JSON.parse(result);
        let groupSearchResultList = [];
        if (groupSearchResultListStr && groupSearchResultListStr.length > 0) {
            groupSearchResultListStr.forEach(g => {
                groupSearchResultList.push(GroupSearchResult.fromProtoGroupSearchResult(g));
            });
        }
        return groupSearchResultList;
    }

    getIncommingFriendRequest() {
        let result = proto.getIncommingFriendRequest();
        let friendRequestListStr = JSON.parse(result);
        let firendRequestList = [];
        if (friendRequestListStr && friendRequestListStr.length > 0) {
            friendRequestListStr.forEach((r) => {
                firendRequestList.push(Object.assign(new FriendRequest(), r));
            });
        }
        return firendRequestList;
    }

    getOutgoingFriendRequest() {
        let result = proto.getOutgoingFriendRequest();
        let friendRequestListStr = JSON.parse(result);
        let firendRequestList = [];
        if (friendRequestListStr && friendRequestListStr.length > 0) {
            friendRequestListStr.forEach((r) => {
                firendRequestList.push(Object.assign(new FriendRequest(), r));
            });
        }
        return firendRequestList;
    }

    getFriendRequest(userId, incomming) {
        let result = proto.getFriendRequest(userId, incomming);
        return JSON.parse(result);
    }

    loadFriendRequestFromRemote() {
        proto.loadFriendRequestFromRemote();
    }

    getFavUsers() {
        let result = proto.getFavUsers();
        return JSON.parse(result);
    }

    isFavUser(groupId) {
        return proto.isFavUser(groupId);
    }

    setFavUser(userId, fav, successCB, failCB) {
        proto.setFavUser(userId, fav, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    loadRemoteMessages(conversation, beforeUid, count, successCB, failCB) {
        proto.getRemoteMessages(JSON.stringify(conversation), beforeUid + '', count, (protoMsgsStr) => {
            var protoMsgs = JSON.parse(protoMsgsStr);
            let msgs = [];
            protoMsgs.map(m => {
                let msg = Message.fromProtoMessage(m);
                if (msg) {
                    msgs.push(msg);
                }
            });
            console.log('getMessages', msgs.length);

            return msgs;
        }, (errorCode) => {
            console.log("loadRemoteMessages failure:", errorCode);
        });
    }

    getUnreadFriendRequestCount() {
        return proto.getUnreadFriendRequestStatus();
    }

    clearUnreadFriendRequestStatus() {
        proto.clearUnreadFriendRequestStatus();
    }

    async deleteFriend(userId, successCB, failCB) {
        proto.deleteFriend(userId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async handleFriendRequest(userId, accept, extra, successCB, failCB) {
        proto.handleFriendRequest(userId, accept, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }

        }, extra);
    }

    isBlackListed(userId) {
        return proto.isBlackListed(userId);
    }

    getBlackList() {
        let result = proto.getBlackList();
        return JSON.parse(result);
    }

    setBlackList(userId, block, successCB, failCB) {
        proto.setBlackList(userId, block, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getMyFriendList(fresh = false) {
        let idsStr = proto.getMyFriendList(fresh);
        if (idsStr !== '') {
            return JSON.parse(idsStr);
        }
        return [];
    }

    getFriendAlias(userId) {
        return proto.getFriendAlias(userId);
    }

    async setFriendAlias(userId, alias, successCB, failCB) {
        proto.setFriendAlias(userId, alias, successCB, failCB);
    }

    async createGroup(groupId, groupType, name, portrait, memberIds = [], lines = [0], notifyContent, successCB, failCB) {
        groupId = !groupId ? '' : groupId;
        let myUid = self.getUserId();

        if (!memberIds.includes(myUid)) {
            memberIds.push(myUid);
        }

        let payload = notifyContent ? notifyContent.encode() : '';
        let notifyContentStr = JSON.stringify(payload);
        //群组类型0，管理员和群主才能加人和退群，修改群信息；2，严格模式，只有群主和管理员才能操作群
        proto.createGroup(groupId, groupType, name, portrait, memberIds, lines, notifyContentStr,
            (groupId) => {
                if (successCB) {
                    successCB(groupId);
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB();
                }
            });
    }

    async setGroupManager(groupId, isSet, memberIds = [], lines = [0], notifyContent, successCB, failCB) {
        let payload = notifyContent ? notifyContent.encode() : '';
        let notifyContentStr = JSON.stringify(payload);
        proto.setGroupManager(groupId, isSet, memberIds, lines, notifyContentStr, successCB, failCB);
    }

    async muteOrAllowGroupMembers(groupId, isSet, isAllow, memberIds, notifyLines = [0], notifyContent, successCB, failCB) {
        if (isAllow) {
            let payload = notifyContent ? notifyContent.encode() : '';
            let notifyContentStr = JSON.stringify(payload);
            proto.allowGroupMember(groupId, isSet, memberIds, notifyLines, notifyContentStr, ()=>{
                successCB && successCB();
            }, (errorCode)=> {
                failCB && failCB();
            });
        } else {
            let payload = notifyContent ? notifyContent.encode() : '';
            let notifyContentStr = JSON.stringify(payload);
            proto.muteGroupMember(groupId, isSet, memberIds, notifyLines, notifyContentStr, ()=>{
                successCB && successCB();
            }, (errorCode) => {
                failCB && failCB(errorCode);
            });
        }
    }

    getGroupInfo(groupId, fresh = false) {
        let groupInfo;
        if (!fresh) {
            groupInfo = self.groups.get(groupId);
            if (groupInfo) {
                return groupInfo;
            }
        }

        console.log('get groupInfo', groupId, fresh);
        let groupInfoStr = proto.getGroupInfo(groupId, fresh);
        if (groupInfoStr === '') {
            return new NullGroupInfo(groupId);
        } else {
            groupInfo = Object.assign(new GroupInfo(), JSON.parse(groupInfoStr));
            self.groups.set(groupId, groupInfo);
            return groupInfo;
        }
    }

    async getGroupInfoEx(groupId, refresh, successCB, failCB) {
        proto.getGroupInfoEx(groupId, refresh, (groupInfoStr) => {
            groupInfo = Object.assign(new GroupInfo(), JSON.parse(groupInfoStr));

            if (successCB) {
                successCB(groupInfo);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    addGroupMembers(groupId, memberIds, notifyLines, notifyMessageContent, successCB, failCB) {
        if (!notifyMessageContent) {
            notifyMessageContent = new AddGroupMemberNotification(self.getUserId(), memberIds);
        }
        let payload = notifyMessageContent.encode();
        let notifyContentStr = JSON.stringify(payload);
        proto.addMembers(memberIds, groupId, notifyLines, notifyContentStr,
            () => {
                if (successCB) {
                    successCB();
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    getGroupMemberIds(groupId, fresh = false) {
        let groupMembers = self.getGroupMembers(groupId, fresh);
        var groupMemberIds = [];
        groupMembers.forEach(e => {
            groupMemberIds.push(e.memberId);
        });
        return groupMemberIds;
    }

    getGroupMembers(groupId, fresh = false) {
        let memberIdsStr = proto.getGroupMembers(groupId, fresh);
        var members = [];
        let arr = JSON.parse(memberIdsStr);
        arr.forEach(e => {
            members.push(Object.assign(new GroupMember(), e));
        });
        return members;
    }

    getGroupMembersByType(groupId, memberType) {
        let memberIdsStr = proto.getGroupMembersByType(groupId, memberType);
        var members = [];
        let arr = JSON.parse(memberIdsStr);
        arr.forEach(e => {
            members.push(Object.assign(new GroupMember(), e));
        });
        return members;
    }

    getGroupMember(groupId, memberId) {
        let result = proto.getGroupMember(groupId, memberId);
        return Object.assign(new GroupMember(), JSON.parse(result));
    }

    async getGroupMembersEx(groupId, refresh, successCB, failCB) {
        proto.getGroupMembersEx(groupId, refresh, (memberIdsStr) => {
            var members = [];
            let arr = JSON.parse(memberIdsStr);
            arr.forEach(e => {
                members.push(Object.assign(new GroupMember(), e));
            });

            if (successCB) {
                successCB(members);
            }
        }, (errorCode) => {
            if (errorCode) {
                failCB(errorCode);
            }

        });
    }

    kickoffGroupMembers(groupId, memberIds, notifyLines, notifyMsg, successCB, failCB) {
        let payload = notifyMsg ? notifyMsg.encode() : '';
        let strCont = JSON.stringify(payload);
        proto.kickoffMembers(groupId, memberIds, notifyLines, strCont,
            () => {
                if (successCB) {
                    successCB();
                }

            }, (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async quitGroup(groupId, lines, notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        proto.quitGroup(groupId, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async dismissGroup(groupId, lines, notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        proto.dismissGroup(groupId, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async modifyGroupInfo(groupId, type, newValue, lines, notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        proto.modifyGroupInfo(groupId, type, newValue, lines, JSON.stringify(payload),
            () => {
                if (successCB) {
                    successCB();
                }
            }, (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            });
    }

    async modifyGroupAlias(groupId, alias, lines, notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        proto.modifyGroupAlias(groupId, alias, lines, JSON.stringify(payload), () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    transferGroup(groupId, newOwner, lines, notifyMessageContent, successCB, failCB) {
        let payload = notifyMessageContent ? notifyMessageContent.encode() : '';
        proto.transferGroup(groupId, newOwner, lines, JSON.stringify(payload), () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getFavGroups() {
        let result = proto.getFavGroups();
        return JSON.parse(result);
    }

    isFavGroup(groupId) {
        return proto.isFavGroup(groupId);
    }

    async setFavGroup(groupId, fav, successCB, failCB) {
        proto.setFavGroup(groupId, fav, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getUserSetting(scope, key) {
        return proto.getUserSetting(scope, key);
    }

    getUserSettings(scope) {
        let result = proto.getUserSettings(scope);
        return JSON.parse(result);
    }

    async setUserSetting(scope, key, value, successCB, failCB) {
        proto.setUserSetting(scope, key, value, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    modifyMyInfo(type, value, successCB, failCB) {
        proto.modifyMyInfo(type, value, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB();
            }
        });
    }

    isGlobalSlient() {
        return proto.isGlobalSlient();
    }

    setGlobalSlient(silent, successCB, failCB) {
        proto.setGlobalSlient(silent, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isHiddenNotificationDetail() {
        return proto.isHiddenNotificationDetail();
    }

    async setHiddenNotificationDetail(hide, successCB, failCB) {
        proto.setHiddenNotificationDetail(hide, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isHiddenGroupMemberName(groupId) {
        return proto.isHiddenGroupMemberName(groupId);
    }

    async setHiddenGroupMemberName(groupId, hide, successCB, failCB) {
        proto.setHiddenGroupMemberName(groupId, hide, () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    isUserReceiptEnabled() {
        return proto.isUserReceiptEnabled();
    }

    async setUserReceiptEnable(enable, successCB, failCB) {
        proto.setUserReceiptEnable(enable, () => {
            successCB();
        }, (errorCode) => {
            failCB(errorCode);
        });
    }

    async joinChatroom(chatroomId, successCB, failCB) {
        proto.joinChatroom(chatroomId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    async quitChatroom(chatroomId, successCB, failCB) {
        proto.quitChatroom(chatroomId, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    async getChatroomInfo(chatroomId, updateDt, successCB, failCB) {
        proto.getChatroomInfo(chatroomId, updateDt, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChatRoomInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    async getChatroomMemberInfo(chatroomId, maxCount, successCB, failCB) {
        proto.getChatroomMemberInfo(chatroomId, maxCount, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChatRoomMemberInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    createChannel(name, portrait, status, desc, extra, successCB, failCB) {
        proto.createChannel(name, portrait, status, desc, extra, (info) => {
            if (successCB) {
                successCB(Object.assign(new ChannelInfo(), JSON.parse(info)));
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getChannelInfo(channelId, refresh) {
        let result = proto.getChannelInfo(channelId, refresh);
        if (result === '') {
            return null;
        }

        return Object.assign(new ChannelInfo(), JSON.parse(result));
    }

    async modifyChannelInfo(channelId, type, newValue, successCB, failCB) {
        proto.modifyChannelInfo(channelId, type, newValue, () => {
            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    searchChannel(keyword, successCB, failCB) {
        proto.searchChannel(keyword, (result) => {
            if (successCB) {
                let channels = [];
                let tmp = JSON.parse(result);
                tmp.forEach(channel => {
                    channels.push(Object.assign(new ChannelInfo(), channel));
                });
                successCB(channels);
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    isListenedChannel(channelId) {
        return proto.isListenedChannel(channelId);
    }

    async listenChannel(channelId, listen, successCB, failCB) {
        proto.listenChannel(channelId, listen, () => {
            successCB();
        }, errorCode => {
            failCB(errorCode);
        });
    }

    // return channelIds
    getMyChannels() {
        let result = proto.getMyChannels();
        return JSON.parse(result);
    }

    getListenedChannels() {
        let result = proto.getListenedChannels();
        return JSON.parse(result);
    }

    async destoryChannel(channelId, successCB, failCB) {
        proto.destoryChannel(channelId, () => {
            if (successCB) {
                successCB();
            }
        }, errorCode => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    getConversationList(types, lines) {
        var conversationListStr = proto.getConversationInfos(types, lines);
        // console.log(conversationListStr);
        // TODO convert to conversationInfo, messageContent

        let conversationInfoList = [];
        let tmp = JSON.parse(conversationListStr);
        tmp.forEach(c => {
            conversationInfoList.push(ConversationInfo.protoConversationToConversationInfo(c));
        });

        return conversationInfoList;
    }

    getConversationInfo(conversation) {
        let convStr = proto.getConversationInfo(JSON.stringify(conversation));
        return ConversationInfo.protoConversationToConversationInfo(JSON.parse(convStr));
    }

    searchConversation(keyword, types = [], lines = []) {
        let result = proto.searchConversation(keyword, types, lines);
        let resultList = JSON.parse(result);
        var conversationSearchResult = [];
        if (resultList && resultList.length > 0) {
            resultList.forEach(r => {
                conversationSearchResult.push(ConversationSearchResult.fromProtoConversationSearchResult(r));
            });
        }
        return conversationSearchResult;
    }

    async removeConversation(conversation, clearMsg) {
        proto.removeConversation(JSON.stringify(conversation), clearMsg);
    }

    setConversationTop(conversation, top, successCB, failCB) {
        proto.setConversationTop(JSON.stringify(conversation), top, () => {
            let conversationInfo = self.getConversationInfo(conversation);
            self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);

            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    setConversationSlient(conversation, silent, successCB, failCB) {
        proto.setConversationSlient(JSON.stringify(conversation), silent, () => {
            let conversationInfo = self.getConversationInfo(conversation);
            self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);

            if (successCB) {
                successCB();
            }
        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    setConversationDraft(conversation, draft = '') {
        proto.setConversationDraft(JSON.stringify(conversation), draft);
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    //timestamp 为毫秒，字符串类型
    setConversationTimestamp(conversation, timestamp) {
        proto.setConversationTimestamp(JSON.stringify(conversation), timestamp);
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    getUnreadCount(types = [], lines = [0]) {
        let unreadCountStr = proto.getUnreadCount(types, lines);
        return Object.assign(new UnreadCount(), JSON.parse(unreadCountStr));
    }

    getConversationUnreadCount(conversation) {
        let unreadCountStr = proto.getConversationUnreadCount(JSON.stringify(conversation));
        return Object.assign(new UnreadCount(), JSON.parse(unreadCountStr));
    }

    clearConversationUnreadStatus(conversation) {
        proto.clearUnreadStatus(JSON.stringify(conversation));
        let conversationInfo = self.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    getConversationRead(conversation) {
        let readedStr = proto.getConversationRead(JSON.stringify(conversation));
        let readedArr = JSON.parse(readedStr);
        let result = new Map();
        if (readedArr) {
            readedArr.forEach(e => {
                result.set(e.key, e.value)
            })
        }
        return result;
    }

    getConversationDelivery(conversation) {
        let deliveryStr = proto.getMessageDelivery(JSON.stringify(conversation));
        let deliveryArr = JSON.parse(deliveryStr);
        let result = new Map();
        if (deliveryArr) {
            deliveryArr.forEach(e => {
                result.set(e.key, e.value)
            })
        }
        return result;
    }

    clearAllUnreadStatus() {
        // TODO emit ConversationInfoUpdate event
        proto.clearAllUnreadStatus();
    }

    getConversationFirstUnreadMessageId(conversation) {
        let messageId = proto.getConversationFirstUnreadMessageId(JSON.stringify(conversation));
        return messageId;
    }

    setMediaMessagePlayed(messageId) {
        // TODO need to emit message update event?
        proto.setMediaMessagePlayed(messageId);
    }

    isMyFriend(userId) {
        return proto.isMyFriend(userId);
    }

    async sendFriendRequest(userId, reason, successCB, failCB) {
        proto.sendFriendRequest(userId, reason, () => {
            if (successCB) {
                successCB();
            }

        }, (errorCode) => {
            if (failCB) {
                failCB(errorCode);
            }
        });
    }

    /**
     *
     * @param {Conversation} conversation
     * @param {number} fromIndex
     * @param {boolean} before
     * @param {number} count
     * @param {string} withUser
     * @param {array} contentTypes
     */
    getMessages(conversation, fromIndex, before = true, count = 20, withUser = '', contentTypes = []) {
        let protoMsgsStr = proto.getMessages(JSON.stringify(conversation), contentTypes, fromIndex, before, count, withUser);
        // let protoMsgsStr = proto.getMessages('xxx', [0], fromIndex, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }


    getMessagesEx(conversationTypes, lines, contentTypes, fromIndex, before = true, count = 20, withUser = '') {
        let protoMsgsStr = proto.getMessagesEx(conversationTypes, lines, contentTypes, fromIndex, before, count, withUser);
        // let protoMsgsStr = proto.getMessages('xxx', [0], fromIndex, before, count, withUser);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getUserMessages(userId, conversation, fromIndex, before = true, count = 20, contentTypes = []) {
        let protoMsgsStr = proto.getUserMessages(userId, JSON.stringify(conversation), contentTypes, fromIndex, before, count);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }


    getUserMessagesEx(userId, conversationTypes, lines, fromIndex, before = true, count = 20, contentTypes = []) {
        let protoMsgsStr = proto.getUserMessagesEx(userId, conversationTypes, lines, contentTypes, fromIndex, before, count);
        var protoMsgs = JSON.parse(protoMsgsStr);
        let msgs = [];
        protoMsgs.map(m => {
            let msg = Message.fromProtoMessage(m);
            if (msg) {
                msgs.push(msg);
            }
        });
        console.log('getMessages', msgs.length);

        return msgs;
    }

    getMessageById(messageId) {
        let mStr = proto.getMessage(messageId);
        return Message.fromProtoMessage(JSON.parse(mStr));
    }

    getMessageByUid(messageUid) {
        let mStr = proto.getMessageByUid(Long.fromValue(messageUid).toString());
        return Message.fromProtoMessage(JSON.parse(mStr));
    }

    searchMessage(conversation, keyword) {
        let result = proto.searchMessage(JSON.stringify(conversation), keyword);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    searchMessageEx(conversation, keyword, desc, limit, offset) {
        let result = proto.searchMessageEx(JSON.stringify(conversation), keyword, desc, limit, offset);
        let msgs = JSON.parse(result);
        let matchMsgs = [];
        if (msgs && msgs.length > 0) {
            msgs.forEach(m => {
                matchMsgs.push(Message.fromProtoMessage(m));
            });
        }

        return matchMsgs;
    }

    async sendConversationMessage(conversation, messageContent, toUsers, preparedCB, progressCB, successCB, failCB) {
        let message = new Message();
        message.conversation = conversation;
        message.messageContent = messageContent;
        self.sendMessageEx(message, toUsers, preparedCB, progressCB, successCB, failCB);
    }

    async sendMessage(message, preparedCB, progressCB, successCB, failCB) {
        self.sendMessageEx(message, [], preparedCB, progressCB, successCB, failCB);
    }

    // toUsers 用来实现定向消息
    async sendMessageEx(message, toUsers = [], preparedCB, progressCB, successCB, failCB) {
        let strConv = JSON.stringify(message.conversation);
        message.content = await message.messageContent.encode();
        message.from = this.userId;
        console.log('--------------p', message.content);
        let strCont = JSON.stringify(message.content);

        proto.sendMessage(strConv, strCont, toUsers, 0,
            function (messageId, timestamp) { //preparedCB
                message.messageId = messageId;
                message.timestamp = Long.fromValue(timestamp).toNumber();
                if (typeof preparedCB === 'function') {
                    preparedCB(messageId, Long.fromValue(timestamp).toNumber());
                }
                self.eventEmitter.emit(EventType.SendMessage, message);
            },
            function (uploaded, total) { //progressCB
                if (typeof progressCB === 'function') {
                    progressCB(uploaded, total);
                }
                // upload progress update
            },
            function (messageUid, timestamp) { //successCB
                message.status = MessageStatus.Sent;
                message.messageUid = Long.fromValue(messageUid);
                message.timestamp = Long.fromValue(timestamp).toNumber();
                // update remote url
                if(message.messageContent instanceof MediaMessageContent){
                    let msg = self.getMessageById(message.messageId);
                    message.messageContent = msg.messageContent;
                }

                if (typeof successCB === 'function') {
                    successCB(Long.fromValue(messageUid), Long.fromValue(timestamp).toNumber());
                }
                self.eventEmitter.emit(EventType.MessageStatusUpdate, message);
            },
            function (errorCode) { //errorCB
                message.status = MessageStatus.SendFailure;
                if (typeof failCB === 'function') {
                    failCB(errorCode);
                }
                self.eventEmitter.emit(EventType.MessageStatusUpdate, message);
            });

    }

    // 更新了原始消息的内容
    async recallMessage(messageUid, successCB, failCB) {
        console.log('recall', messageUid);
        proto.recall(messageUid.toString(),
            () => {
                console.log('recall, s', messageUid);
                if (successCB) {
                    successCB();
                }
                this.onRecallMessage(this.getUserId(), messageUid);
            },
            (errorCode) => {
                console.log('recall, f', messageUid, errorCode);
                if (failCB) {
                    failCB();
                }
            });
    }

    // async deleteRemoteMessageByUId(messageUid) {
    //   console.log('deleteRemoteMessageByUId', messageUid);
    //   proto.deleteRemoteMessage(messageUid.toString(),
    //       () => {
    //           console.log('recall, s', messageUid);
    //           if (successCB) {
    //               successCB();
    //           }
    //           this.onDeleteRemoteMessage(messageUid);
    //       },
    //       (errorCode) => {
    //           console.log('recall, f', messageUid, errorCode);
    //           if (failCB) {
    //               failCB();
    //           }
    //       });
    // }

    deleteMessageById(messageId) {
        let result = proto.deleteMessage(messageId);
        if (result) {
            this.onMessageDeleted(messageId);
        }
        return result;
    }

    isCommercialServer() {
        return proto.isCommercialServer();
    }

    isReceiptEnabled() {
        return proto.isReceiptEnabled();
    }


    getAuthorizedMediaUrl(messaggeUid, mediaType, mediaPath, successCB, failCB) {
        proto.getAuthorizedMediaUrl(messaggeUid, mediaType, mediaPath, successCB, failCB);
    }


    getConversationFileRecords(conversation, fromUser, beforeUid, count, successCB, failCB) {
        proto.getConversationFiles(JSON.stringify(conversation), fromUser, Long.fromValue(beforeUid).toString(), count, (frsStr) => {
            let frs = JSON.parse(frsStr);
            let fileRecords = [];
            frs.forEach(fr => {
                fileRecords.push(this._objStrToFileRecordObj(fr));
            })
            successCB && successCB(fileRecords);
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    _objStrToFileRecordObj(obj) {

        let fileRecord = new FileRecord();
        fileRecord.userId = obj.userId;
        fileRecord.conversation = new Conversation(obj.conversationType, obj.target, obj.line);
        fileRecord.messageUid = Long.fromValue(obj.messageUid);
        fileRecord.name = obj.name;
        fileRecord.url = obj.url;
        fileRecord.size = obj.size;
        fileRecord.downloadCount = obj.downloadCount;
        fileRecord.timestamp = obj.timestamp;

        return fileRecord;
    }

    getMyFileRecords(beforeUid, count, successCB, failCB) {
        proto.getMyFiles(Long.fromValue(beforeUid).toString(), count, (frsStr) => {
            let frs = JSON.parse(frsStr);
            let fileRecords = [];
            frs.forEach(fr => {
                fileRecords.push(this._objStrToFileRecordObj(fr));
            })
            successCB && successCB(fileRecords);
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    deleteFileRecord(messageUid, successCB, failCB) {
        proto.deleteFileRecord(Long.fromValue(messageUid).toString(), () => {
            successCB && successCB();
        }, (errorCode) => {
            failCB && failCB(errorCode);
        });
    }

    async clearMessages(conversation) {
        proto.clearMessages(JSON.stringify(conversation));
        let conversationInfo = this.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    /**
     * 删除before时间之前的所有消息
     *
     * @param {Conversation} conversation
     * @param {String} before 时间精度到毫秒，字符串格式
     */
    async clearMessagesByTime(conversation, before) {
        proto.clearMessagesByTime(JSON.stringify(conversation), before);
        let conversationInfo = this.getConversationInfo(conversation);
        self.eventEmitter.emit(EventType.ConversationInfoUpdate, conversationInfo);
    }

    /**
     *
     * @param {Conversation} conversation
     * @param {MessageContent} messageContent
     * @param {MessageStatus} status
     * @param {boolean} notify 是否触发onReceiveMessage
     * @param {Number} serverTime 服务器时间，精度到毫秒
     */
    insertMessage(conversation, messageContent, status, notify = false, serverTime = 0) {
        proto.insertMessage(JSON.stringify(conversation), self.userId, JSON.stringify(messageContent), status, notify, serverTime);
    }

    async updateMessageContent(messageId, messageContent) {
        let protoMessageContent = messageContent.encode();
        proto.updateMessage(messageId, JSON.stringify(protoMessageContent));
    }

    async updateMessageStatus(messageId, status) {
        proto.updateMessageStatus(messageId, status);
    }

    async uploadMedia(fileName, data, mediaType, successCB, failCB, progressCB) {
        // var data = file.slile(0, file.size);
        if (data instanceof File) {
            data = await fs.readFile(data.path, {encoding: 'base64'});
        }
        if (data.indexOf("base64,") >= 0) {
            data = data.substring(data.indexOf(',') + 1);
        }
        proto.uploadMedia(fileName, data, mediaType,
            (remoteUrl) => {
                if (successCB) {
                    successCB(remoteUrl);
                }
            },
            (errorCode) => {
                if (failCB) {
                    failCB(errorCode);
                }
            },
            (current, total) => {
                if (progressCB) {
                    progressCB(current, total);
                }
            });
    }

    sendConferenceRequest(sessionId, roomId, request, data, callback){
        proto.sendConferenceRequest('' + sessionId, roomId, request, data,
            (resp) => {
                callback && callback(0, resp);
            },
            (errorCode) =>{
                callback && callback(errorCode, null)
            });
    }
}

const self = new WfcImpl();
export default self;
